#+TITLE: ASM Interpret

-- A small Assembly (ish) DSL for the purpose of teaching new coders differences
between high and low languages
* Brief
** Research
In developing the program, a number of design decisions are needed to be made
in order to develop a working product.
*** Audience
As the primary stakeholders for the program are mainly students, the program
needs to be tended towards them in order to ensure that they can use the
program effectively.

In order to learn what sorts of elements I needed for this program I looked at
other educational assemblies that predate my project and collected notes based
on what I thought I could incorporate:

- Little Man Computer
  [[https://en.wikipedia.org/wiki/Little_man_computer][Wikipedia Page]]. Little Man Computer is an educational base-10 executable code
  or assembly language designed to emulate the basics of a modern computer.
  The language is capable of control flow, arithmetic, basic IO and stored
  memory. From here I took the concepts of stored memory, which I wasn't
  planning on doing originally, because in studying the[[https://en.wikipedia.org/wiki/Von_Neumann_architecture][ Von Neumann Architecture]]
  I realized that the concepts of memory management are an important concept for
  students learning about lower level languages to grasp. Often in higher level
  languages that are commonly used for teaching (e.g python, javascript, ruby)
  understanding that memory is a physical thing they can write to is something
  that is rather important. This is particularly when programmers in real life face heap
  and stack errors it's important to understand that memory is finite, as well
  as how and where you would choose to write to memory in general.
- Crunch
  [[http://codio.com/docs/teacher/special/crunch/][Crunch by codio]] is offered as a modern alternative to Little Man Computer.
  Crunch features a far more complex view of the CPU and instructional
  programming than Little Man Computer does. For example, as far as my research
  can tell me, Little Man Computer features no concept of a stack. Crunch
  however does feature a stack, which can be pushed and popped from as you would
  expect. Crunch is also modelled more closely with actual modern assembly than
  Little Man Computer is which inevitably means it carries a lot of the tradition
  that assembly does as well (e.g JMP for jumping to a label). From here I took
  the prompt (being a simple ">"), which while I thought was a little too vague
  as an input guider I realized could be used provided enough documentation was
  included.
** Stakeholders
In developing this solution I identified a few stakeholders whose opinions were
integral to it's success. These stakeholders were the students, and the teacher.
A more detailed break down (including their needs) is listed below:


- Students :: If the ultimate goal of the solution is to show students what
     programming in a low level environment looks like, then such a program
     needs two things. Firstly it needs to *emulate* the environment of a low
     level program, which includes registers, memory management, and common
     instructions to manipulate them. Secondly, and perhaps more importantly, it
     needs to *instruct*, *inform* and *educate* the student on what they're actually
     doing. This can be achieved through documentation of how the program works,
     including analogies to real world scenarios, and also importantly providing
     comprehensive feedback on what each instruction they're running is doing.
- Teacher :: The teacher's needs are related but not identical to that of the
     student. The teacher's ultimate goal to to educate and inform students on
     how low level languages generally work. In order to do that a teacher needs
     a program that is adaptable to any learning environment, and caters for
     both those who are relatively independant (in that they'll want to do
     things for themselves to find out), and those who prefer the guidance of a
     teacher in general. In order for that to be achieved, the program needs to
     be *flexible*, *discoverable* and *documented*. If the program is flexible, then those who are
     independant can work on their own, discovering nuance of low level code,
     whilst those who need it can be taught by the teacher. Moreover for those
     who do require a teacher's guidance, documentation is important to ensure
     that any teacher can provide quick example demonstrating low level concepts
     without quickly and easily. This might be achieved with example programs
     for each low level concept the outcome is capable of reproducing

Overall, from both teachers and students, I have identified key points that need
to be focused on in order for success to be achieved.

1. Emulation. Without an emulated environment neither documentation nor
   discoverability will achieve the goal.
2. Documentation. The program needs to have comprehensive documentation in order
   for the teacher to teach properly, and the students to understand what
   they're doing.
3. Discoverability. Independant students are going to want to learn the ropes
   themselves. In order for that to be achieved, they are going to need feedback
   from the program that shows exactly what the program is doing at a given
   time.
Additionally, as my perspective as the developer, I have my own values that
aren't necessarily in the interests of students or teachers, but benefit them
nonetheless.
1. Extensibility. The code base needs to be able to be extended quickly and
   easily, through abstracted details and standardized interfaces.
2. Foolproof Code. The code needs to be able to withstand any input, as this
   kind of project relies heavily on user input, I cannot be sure what they'll
   enter. Thus I need an easy way of showing that the code I write will work in
   all cases.
3. Simplicity. Almost as a requirement of the previous two, the code needs to
   remain simple and require little to no dependencies bar a standard library.
4. Cross Platform. The code needs to be able to be compiled for Windows, Mac OS
   X, and Linux in simple steps. Provided the code base is simple, and projects
   like mingw do their job, this should be easy to carry out.

** Social Environment And Background
The social needs of program also need to be identified. From a societal
perspective, there is almost no way to go wrong here. Nobody is likely to be
offended by the design of this program, as it really asks nothing personal of
the user or requires the user to interact personally with it. However there is one main
environmental factor that needs to be accounted for.

- Prior knowledge :: The environment this program is aimed at is those who may
     have prior knowledge of coding (although possibly not), and those who haven't
     had much in low level programming. In order to account for this, simple
     design should be employed to ensure that the user doesn't become swamped with
     too much information too fast.
** TODO Opinions of Stake Holders
** Code Design
The design is broken into multiple pieces for consistency and compatibility
reasons.
*** Directory Tree
#+BEGIN_EXAMPLE
.
├── include
├── lib
│   ├── include
│   │   └── opcodes.h
│   └── src
│       └── opcodes.c
├── README.org
└── src
    ├── asm_interpreter
    └── main.c
#+END_EXAMPLE
- Essentially there is one library (the lib folder) called libasminterpreter, which backends all the
  logic, and is strictly cross platform. Code here is expected to be much higher
  quality than usual (to make it easier to debug). The kind of logic
  expected here would be the binary interpreter and other macros/functions for the internals of the
  asm-like language on a whole.
- The other component to the puzzle is the os related presentation code. This
  code acts as a front end, providing the UI and other related components (such as file
  IO etc). This is found in the "src" directory.
- README.org is what you are reading now.
- main.c is the main file for the UI code, in that it is the fallback if no
  better options exist when compiling. The means that if you are on a system
  like Windows, it will compile this file because no GUI code exists for it
  (yet).
- asm_interpreter (asm_interpreter.exe for windows systems) is the compiled
  executable.
There are a few other files, notably CMakeLists.txt and .clang_complete but
these can be safely ignored (they don't provide anything code wise, they are
just for building). Upon building *a ton of files will be created*, ignore these
too.
*** The Assembly Itself
The assembly DSL differs greatly from the real assembly (things like nasm,
etc.), in that it is entirely written in binary. Each instruction in this
language, for simplicity's sake on my part, is 16 bits long. This was chosen to
leave plenty of room for maneuvering and flexibility in function arguments. An
example instruction might look like:
#+BEGIN_QUOTE
0000 0000 0001 0000
#+END_QUOTE
In this case, an ADD instruction was called, adding register 2 to register 1
storing the result with register 1. Notice that even though the add instruction
takes only 2 arguments (two registers respectively), the third still has to be
written out. This bit padding, as it is referred to, is rather common because it
allow the parsers to guarantee an exact amount of bits per instruction and don't need
variable length buffers to hold the information (which are a nightmare).

This assembly isn't complex, there aren't many obscurities. Users do not need to
know if they are developing for x86_64 architecture or whether memory is
available. This is for a few reasons, firstly because the students may or not be
able to grasp memory management concepts, and because these sort of things
aren't required to show properly the verbose nature of machine code and
assembly. The purpose of this program isn't to make people whizzes at assembly,
rather encourage learning of binary numbers and show that low level languages
are highly verbose and take large swaths of code to achieve simple tasks.

**** Table of Op Codes
| Code | Arguments    | Binary | Explanation                                                        |
|------+--------------+--------+--------------------------------------------------------------------|
| ADD  | REG1, REG2   |   0000 | Add the contents of REG2 to REG1, storing the result in REG1       |
| MUL  | REG1, REG2   |   0001 | Multiply the contents of REG2 and REG1, storing the result in REG1 |
| DIV  | REG1, REG2   |   0010 | Divide REG1 by REG2, and store the result in REG1                  |
| SUB  | REG1, REG2   |   0011 | Subtract REG2 from REG1, storing the result in REG1                |
| LD   | REG1, MEMLOC |   0100 | Load Memloc (fake location in memory) into REG1                    |
| SAV  | REG1, MEMLOC |   0101 | Copy REG1 to MEMLOC                                                |
| P    | REG1         |   0110 | Print the contents of REG1                                         |
| STO  | REG1, MEMLOC |   0111 | Store (destructively) REG1 in MEMLOC                               |
| SET  | REG1, VAL    |   1000 | Set the Value of REG1 to VAL                                       |
|      |              |        |                                                                    |
