#+TITLE: ASM Interpret

-- A small Assembly (ish) DSL for the purpose of teaching new coders differences
between high and low languages
* Brief
** Research
In developing the program, a number of design decisions are needed to be made
in order to develop a working product.
*** Audience
As the primary stakeholders for the program are mainly students, the program
needs to be tended towards them in order to ensure that they can use the
program effectively.

In order to learn what sorts of elements I needed for this program I looked at
other educational assemblies that predate my project and collected notes based
on what I thought I could incorporate:

- Little Man Computer
  [[https://en.wikipedia.org/wiki/Little_man_computer][Wikipedia Page]]. Little Man Computer is an educational base-10 executable code
  or assembly language designed to emulate the basics of a modern computer.
  The language is capable of control flow, arithmetic, basic IO and stored
  memory. From here I took the concepts of stored memory, which I wasn't
  planning on doing originally, because in studying the[[https://en.wikipedia.org/wiki/Von_Neumann_architecture][ Von Neumann Architecture]]
  I realized that the concepts of memory management are an important concept for
  students learning about lower level languages to grasp. Often in higher level
  languages that are commonly used for teaching (e.g python, javascript, ruby)
  understanding that memory is a physical thing they can write to is something
  that is rather important. This is particularly when programmers in real life face heap
  and stack errors it's important to understand that memory is finite, as well
  as how and where you would choose to write to memory in general.
- Crunch
  [[http://codio.com/docs/teacher/special/crunch/][Crunch by codio]] is offered as a modern alternative to Little Man Computer.
  Crunch features a far more complex view of the CPU and instructional
  programming than Little Man Computer does. For example, as far as my research
  can tell me, Little Man Computer features no concept of a stack. Crunch
  however does feature a stack, which can be pushed and popped from as you would
  expect. Crunch is also modelled more closely with actual modern assembly than
  Little Man Computer is which inevitably means it carries a lot of the tradition
  that assembly does as well (e.g JMP for jumping to a label). From here I took
  the prompt (being a simple ">"), which while I thought was a little too vague
  as an input guider I realized could be used provided enough documentation was included.

** Code Design
The design is broken into multiple pieces for consistency and compatibility
reasons.
*** Directory Tree
#+BEGIN_EXAMPLE
.
├── include
├── lib
│   ├── include
│   │   └── opcodes.h
│   └── src
│       └── opcodes.c
├── README.org
└── src
    ├── asm_interpreter
    └── main.c
#+END_EXAMPLE
- Essentially there is one library (the lib folder) called libasminterpreter, which backends all the
  logic, and is strictly cross platform. Code here is expected to be much higher
  quality than usual (to make it easier to debug). The kind of logic
  expected here would be the binary interpreter and other macros/functions for the internals of the
  asm-like language on a whole.
- The other component to the puzzle is the os related presentation code. This
  code acts as a front end, providing the UI and other related components (such as file
  IO etc). This is found in the "src" directory.
- README.org is what you are reading now.
- main.c is the main file for the UI code, in that it is the fallback if no
  better options exist when compiling. The means that if you are on a system
  like Windows, it will compile this file because no GUI code exists for it
  (yet).
- asm_interpreter (asm_interpreter.exe for windows systems) is the compiled
  executable.
There are a few other files, notably CMakeLists.txt and .clang_complete but
these can be safely ignored (they don't provide anything code wise, they are
just for building). Upon building *a ton of files will be created*, ignore these
too.
*** The Assembly Itself
The assembly DSL differs greatly from the real assembly (things like nasm,
etc.), in that it is entirely written in binary. Each instruction in this
language, for simplicity's sake on my part, is 16 bits long. This was chosen to
leave plenty of room for maneuvering and flexibility in function arguments. An
example instruction might look like:
#+BEGIN_QUOTE
0000 0000 0001 0000
#+END_QUOTE
In this case, an ADD instruction was called, adding register 2 to register 1
storing the result with register 1. Notice that even though the add instruction
takes only 2 arguments (two registers respectively), the third still has to be
written out. This bit padding, as it is referred to, is rather common because it
allow the parsers to guarantee an exact amount of bits per instruction and don't need
variable length buffers to hold the information (which are a nightmare).

This assembly isn't complex, there aren't many obscurities. Users do not need to
know if they are developing for x86_64 architecture or whether memory is
available. This is for a few reasons, firstly because the students may or not be
able to grasp memory management concepts, and because these sort of things
aren't required to show properly the verbose nature of machine code and
assembly. The purpose of this program isn't to make people whizzes at assembly,
rather encourage learning of binary numbers and show that low level languages
are highly verbose and take large swaths of code to achieve simple tasks.

**** Table of Op Codes
| Code | Arguments    | Binary | Explanation                                                        |
|------+--------------+--------+--------------------------------------------------------------------|
| ADD  | REG1, REG2   |   0000 | Add the contents of REG2 to REG1, storing the result in REG1       |
| MUL  | REG1, REG2   |   0001 | Multiply the contents of REG2 and REG1, storing the result in REG1 |
| DIV  | REG1, REG2   |   0010 | Divide REG1 by REG2, and store the result in REG1                  |
| SUB  | REG1, REG2   |   0011 | Subtract REG2 from REG1, storing the result in REG1                |
| LD   | REG1, MEMLOC |   0100 | Load Memloc (fake location in memory) into REG1                    |
| SAV  | REG1, MEMLOC |   0101 | Copy REG1 to MEMLOC                                                |
| P    | REG1         |   0110 | Print the contents of REG1                                         |
| STO  | REG1, MEMLOC |   0111 | Store (destructively) REG1 in MEMLOC                               |
| SET  | REG1, VAL    |   1000 | Set the Value of REG1 to VAL                                       |
|      |              |        |                                                                    |
